;; First, we define a stateful function that adds its input to an internal counter, initialized to 0.

;; The function returns a new counter value and a commitment to a replacement function wrapping the new counter.

!(commit (letrec ((add (lambda (counter x)
                          (let ((counter (+ counter x)))
                            (cons counter (commit (add counter)))))))
            (add 0)))

;; We chain a next commitment by applying the committed function to a value of 9.

!(chain #0x654d995f929e8603565704cc8b01c2cc9d0868a07ffc687fb927540f72e98f 9)

;; The new counter value is 9, and the function returns a new functional commitment.

;; This new commitment is now the head of the chain.

;; Next, we ccreate a proof of this transition.

!(prove)

;; We can verify the proof.

!(verify "11f357c380d244586cdb39d2414dabce9f12cc2f5b25fd7ef750b696e17117")

;; Now let's chain another call to the new head, adding 12 to the counter.

!(chain #0x1028a4286fae85685b4e098c8cf66def69c1eec5437a72a88aa0e38dca3808 12)

;; Now the counter is 21, and we have a new head commitment.

;; Prove it.

!(prove)

;; And verify.

!(verify "35041b74b780dae7ec87e1e83c8d9340e10708eb9370e87bfb657b1345f1ea")

;; One more time, we'll add 14 to the head commitment's internal state.

!(chain #0x2b2b7cbe691e08a93e98472fc852fa3415300fd046879059500d3b113f4fb4 14)

;; 21 + 14 = 35, as expected.

;; Prove.

!(prove)

;; Verify.

!(verify "48fa4dd09b1d27150fdcd8074ec1a7d45fe26a90a7401c3901e9396220cd34")

;; Repeat indefinitely.

;; At every step, we have proof that the head commitment was correctly derived from the previous and some input.
