;; First, we define a stateful function that adds its input to an internal counter, initialized to 0.

;; The function returns a new counter value and a commitment to a replacement function wrapping the new counter.

!(commit (letrec ((add (lambda (counter x)
                          (let ((counter (+ counter x)))
                            (cons counter (commit (add counter)))))))
            (add 0)))

;; We chain a next commitment by applying the committed function to a value of 9.

!(chain #0x5a34ed7712c5fd2f324feb0e1764b27bac9259c4b663e4601e678939a9363d 9)

;; The new counter value is 9, and the function returns a new functional commitment.

;; This new commitment is now the head of the chain.

;; Next, we ccreate a proof of this transition.

!(prove)

;; We can verify the proof.

!(verify "68bf8123715dcc0e230971dbff2edc365f5e0e1ec82518cda637b3ac49a4ab")

;; Now let's chain another call to the new head, adding 12 to the counter.

!(chain #0x7ef60daca90d37a29e5bb066615f925148f07ced803855f41907e7ace3d066 12)

;; Now the counter is 21, and we have a new head commitment.

;; Prove it.

!(prove)

;; And verify.

!(verify "13b40e5aac59c950f2be0092c4c4f745be4c526711912933b8b3a466107cbb")

;; One more time, we'll add 14 to the head commitment's internal state.

!(chain #0x7edc8f2fc3ddab594374d9e4344c7160f65b77b0e4f9da7292c63faa667fc7 14)

;; 21 + 14 = 35, as expected.

;; Prove.

!(prove)

;; Verify.

!(verify "778deec686e6e2db8247630ca76c30665a44a5082f15d63a7737af83de1a46")

;; Repeat indefinitely.

;; At every step, we have proof that the head commitment was correctly derived from the previous and some input.
