;; First, we define a stateful function that adds its input to an internal counter, initialized to 0.

;; The function returns a new counter value and a commitment to a replacement function wrapping the new counter.

!(commit (letrec ((add (lambda (counter x)
                          (let ((counter (+ counter x)))
                            (cons counter (commit (add counter)))))))
            (add 0)))

;; We chain a next commitment by applying the committed function to a value of 9.

!(chain #0x545e921e6ef944cd72811575b1064f8737d520cd04dd75a47ad6c5bf509ea7 9)

;; The new counter value is 9, and the function returns a new functional commitment.

;; This new commitment is now the head of the chain.

;; Next, we ccreate a proof of this transition.

!(prove)

;; We can verify the proof.

!(verify "728e57b72d7d05e5356f8fb218fa26f053e8851f4cbf7372c9441460496b21")

;; Now let's chain another call to the new head, adding 12 to the counter.

!(chain #0x360823fcaffc682078bccb4b38e24620faf4255866f771f5371e3f28dac21d 12)

;; Now the counter is 21, and we have a new head commitment.

;; Prove it.

!(prove)

;; And verify.

!(verify "3415622ca92481bae4e55ba49b44ab53987064f4cbfcb51805a1bce14d2f88")

;; One more time, we'll add 14 to the head commitment's internal state.

!(chain #0x6cd6765d9d15e7f771b4a10adedf32bbf5fbe35f8815f9d8bd6a6b9a485987 14)

;; 21 + 14 = 35, as expected.

;; Prove.

!(prove)

;; Verify.

!(verify "65dbb2b7a29e01514ccf4463826c4c799c101ed60ffd89f2b5f83706a9e00e")

;; Repeat indefinitely.

;; At every step, we have proof that the head commitment was correctly derived from the previous and some input.
